## TCP:Transmission Control Protocol 传输控制协议

tcp是一个面向连接的、可靠的、基于字节流的传输层。

面向连接：是指 TCP 是面向客户端和服务器端连接的通讯协议，使用它可以将客户端和服务器端进行连接。

可靠性：是指无论网络环境多差，TCP 都可以保证信息一定能够传递到接收端。TCP 之所以可以保证可靠性主要得益于两个方面，一个是“状态性”，另一个是“可控制性”。所谓状态性是指 TCP 会记录信息的发送状态，例如，哪些数据收到了、哪些数据没收到等状态信息都会被记录；可控制性是指 TCP 会根据状态情况控制自己的行为，比如当 TCP 意识到丢包了就会控制重发此包，这样就实现了 TCP 的可靠性。

面向字节流：是指 TCP 是以字节流的方式进行数据传输的。


<img src="https://img-blog.csdnimg.cn/img_convert/845c4d39e309d80b57ba4d2a88021a4c.png" alt="TCP头格式"  />

![img](https://img-blog.csdnimg.cn/img_convert/5c96d635f4c09c2d28e3e51eb87a9142.png)



- TCP的包是没有IP地址的，那是IP层上的事。但是有源端口和目标端口。
- 一个TCP连接需要四个元组来表示是同一个连接（src_ip, src_port, dst_ip, dst_port）准确说是五元组，还有一个是协议。但因为这里只是说TCP协议，所以，这里我只说四元组。
- 注意上图中的四个非常重要的东西：
- - Sequence Number是包的序号，用来解决网络包乱序（reordering）问题。
  - Acknowledgement Number就是ACK——用于确认收到，用来解决不丢包的问题。
- - Window又叫Advertised-Window，也就是著名的滑动窗口（Sliding Window），用于解决流控的。
  - TCP Flag ，也就是包的类型，主要是用于操控TCP的状态机的。

![img](https://img-blog.csdnimg.cn/img_convert/03b8bc507aea6152da4894ff353ddd7b.png)

## 1.三次握手

###### 1.1第一次握手

客户端发送一个请求连接报文段，该报文段携带一个0数据的同步位SYN和数据序号为X。进入了SYN_SENT状态等待服务器确定。

```
第一次握手，客户端发送同步报文到服务端，客户端知道自己有发送数据能力，不知道服务端是否有发送、接受数据能力。
```

###### 1.2第二次握手

服务器同意连接，并向客户端发送一个请求连接确认报文段，该报文段包括同步为SYN=1、确认位ACK=1、数据初始序号seq=y以及对客户端发送的请求连接的数据序号进行确认ack=x+1。该报文段也不带数据。

```
第二次握手，服务端收到同步报文，并回复确认同步报文，此时，服务端知道自己有接收、发送数据能力，并且客服端有发送数据能力，但不知道客户端是否有接收数据能力。
```

###### 1.3第三次握手

客户端接收到服务器发送的连接请求后，会再一次发送一个普通的TCP确认报文段，该报文段包括确认位ACK=1、序号为seq=x+1和对服务器发送的连接请求的序号进行确认ack=y+1

```
第三次握手，当客户端收到确认同步报文后，知道服务端具备发送、接收能力，也知道自己具备，但是服务端只知道客户端具备发送能力，还不知道也有接收能力，所以需要发送确认报文，告诉服务端自己具备接收能力。
```

当三次握手流程结束后，客户端服务端都知道自己和对方具备发送、接收数据能力，建立连接完成，就可以进行数据传输了。

是否能该为两次握手？

不能，因为有可能在TCP客户端发送的请求连接报文段没有被服务端接收，滞留在网络中。然后超时重传一个客户端TCP请求连接报文段，该报文段被正确接收了，此时服务器已经进入了连接状态，并给客户端发送一个确认报文段，客户端接收到后就进入了已连接状态，并开始传输数据，直到释放连接之后，之前停留在网络中的客户端发送的TCP请求连接报文段被服务器正确接收到了，进入连接状态，等待客户端传输数据，但是此时客户端已经关闭了，但是负端并不知道，一直在等待，这就造成了大量资源的浪费。

## 2.四次挥手

###### 2.1第一次挥手

客户端发送一个释放连接TCP数据报文段，该报文段包括释放连接标记FIN=1、确认位ACK=1（已收到服务器上一次传来的数据）、序号位seq=u（u=客户端传输数据结束后的序号位置+1）确认序号ack=v（v=服务器传来数据时的序号+1）。进入终止连接状态1

```
第一次挥手客户端发起关闭连接的请求给服务端；
```

###### 2.2第二次挥手

服务器进入关闭等待状态，并向客户端发送一条普通的TCP确认报文段，该报文段包括确认位ACK=1、序号位seq=v（v=服务器当前数据的序号），确认序号ack=u+1（对客户端第一次传来的释放连接请求序号进行确认）。此时服务器还有数据没有传输完则会继续传输数据给客户端，客户端进入终止等待状态2

```
第二次挥手：服务端收到关闭请求的时候可能这个时候数据还没发送完，所以服务端会先回复一个确认报文，表示自己知道客户端想要关闭连接了，但需要等待数据传输完；
```

###### 2.3第三次挥手

服务器没有数据后会向客户端发送一条TCP释放连接报文段，该报文段包括终止连接FIN=1、确认位ACK=1、序号位seq=w（w=当前服务器传输完数据之后的序号位）、ack=u+1。进入确认状态。

```
第三次挥手，当数据传输完，服务端会主动发送FIN报文，告知客户端，标识数据已发送给你，服务端准备关闭连接了。
```

###### 2.4第四次挥手

客户端回向服务器发送一个TCP确认报文段，该报文段包括确认位ACK=1、序号位seq=u+1（客户端当前数据位序号+1）、确认序号ack=w+1（服务器数据序号位+1）。服务器收到该报文段后就关闭连接了，而客户端则进入时间等待状态等待2MSL， 在进行等待的两分钟内没有收到服务器的报文段就关闭连接了

```
第四次挥手，当客户端收到服务端的FIN报文后，会回复ACK报文，告知服务端自己知道了，在等待一会就关闭连接。
```

2MSL等待是否有必要？

假如客户端最后发送的对服务器的确认报文段在网络中丢失了，服务器并没有收到来自客户端的确认报文段，然后继续向和客户端发送释放连接报文段，但是客户端已经关闭了，不在接收报文段，这就会导致服务器一直处于最后确认状态而不能关闭



## 3.TCP重连机制

**TCP要保证所有的数据包都可以到达，所以，必需要有重传机制。**

注意:接收端给发送端的Ack确认只会确认最后一个连续的包，比如，发送端发了1,2,3,4,5一共五份数据，接收端收到了1，2，于是回ack 3，然后收到了4（注意此时3没收到），此时的TCP会怎么办？我们要知道，因为正如前面所说的，**SeqNum和Ack是以字节数为单位，所以ack的时候，不能跳着确认，只能确认最大的连续收到的包**，不然，发送端就以为之前的都收到了。

###### 3.1超时重传机制

一种是不回ack，死等3，当发送方发现收不到3的ack超时后，会重传3。一旦接收方收到3后，会ack 回 4，意味着3和4都收到了。

但是，这种方式会有比较严重的问题，那就是因为要死等3，所以会导致4和5即便已经收到了，而发送方也完全不知道发生了什么事，因为没有收到Ack，所以，发送方可能会悲观地认为也丢了，所以有可能也会导致4和5的重传。

因为ack是必须连续确认的

对此有两种选择：

- 一种是仅重传timeout的包。也就是第3份数据。
- 另一种是重传timeout后所有的数据，也就是第3，4，5这三份数据。

这两种方式有好也有不好。第一种会节省带宽，但是慢，第二种会快一点，但是会浪费带宽，也可能会有无用功。但总体来说都不好，因为都在等timeout，timeout可能会很长。

###### 3.2快速重传机制

TCP引入了一种叫**Fast Retransmit** 的算法，**不以时间驱动，而以数据驱动重传**。也就是说，如果，包没有连续到达，就ack最后那个可能被丢了的包，如果发送方连续收到3次相同的ack，就重传。Fast Retransmit的好处是不用等timeout了再重传。

比如：如果发送方发出了1，2，3，4，5份数据，第一份先到送了，于是就ack回2，结果2因为某些原因没收到，3到达了，于是还是ack回2，后面的4和5都到了，但是还是ack回2，因为2还是没有收到，于是发送端收到了三个ack=2的确认，知道了2还没有到，于是就马上重转2。然后，接收端收到了2，此时因为3，4，5都收到了，于是ack回6。示意图如下：

![img](https://img-blog.csdnimg.cn/img_convert/12a43bce943cd7761f81edb33c32a235.png)

Fast Retransmit只解决了一个问题，就是timeout的问题，它依然面临一个艰难的选择。就是，是重传之前的一个还是重传所有的问题。对于上面的示例来说，是重传#2呢还是重传#2，#3，#4，#5呢？因为发送端并不清楚这连续的3个ack(2)是谁传回来的？也许发送端发了20份数据，是#6，#10，#20传来的呢。这样，发送端很有可能要重传从2到20的这堆数据（这就是某些TCP的实际的实现）。可见，这是一把双刃剑。

###### 3.3SACK方法

优化重传单个还是所有的问题。

另外一种更好的方式叫：**Selective Acknowledgment (SACK)**（参看[RFC 2018(opens new window)](https://tools.ietf.org/html/rfc2018)），这种方式需要在TCP头里加一个SACK的东西，ACK还是Fast Retransmit的ACK，SACK则是汇报收到的数据碎版。参看下图：

![img](https://img-blog.csdnimg.cn/img_convert/a4b2ac312e9217555684a7bc2f1a4089.png)

这样，在发送端就可以根据回传的SACK来知道哪些数据到了，哪些没有到。于是就优化了Fast Retransmit的算法。当然，这个协议需要两边都支持。在 Linux下，可以通过tcp_sack参数打开这个功能（Linux 2.4后默认打开）。

这里还需要注意一个问题——**接收方Reneging，所谓Reneging的意思就是接收方有权把已经报给发送端SACK里的数据给丢了**。这样干是不被鼓励的，因为这个事会把问题复杂化了，但是，接收方这么做可能会有些极端情况，比如要把内存给别的更重要的东西。所以，**发送方也不能完全依赖SACK，还是要依赖ACK，并维护Time-Out，如果后续的ACK没有增长，那么还是要把SACK的东西重传，另外，接收端这边永远不能把SACK的包标记为Ack**。

注意：SACK会消费发送方的资源，试想，如果一个攻击者给数据发送方发一堆SACK的选项，这会导致发送方开始要重传甚至遍历已经发出的数据，这会消耗很多发送端的资源。详细的东西请参看[《TCP SACK的性能权衡》](https://www.ibm.com/developerworks/cn/linux/l-tcp-sack/)

### TCP引入了RTT——Round Trip Time，也就是一个数据包从发出去到回来的时间。

## TCP窗口滑动

我们都知道，TCP必需要解决的可靠传输以及包乱序（reordering）的问题，所以，TCP必需要知道网络实际的数据处理带宽或是数据处理速度，这样才不会引起网络拥塞，导致丢包。

TCP会以段为单位，每发一个段就进行一次确认应答处理，但是这样的传输方式，如果数据包在网络中往返的时间越长，网络通信的效率就会越低。

为了解决上面的问题，TCP中引入了滑动窗口的概念。有了滑动窗口后，即使数据包在网络中往返时间较长，也可以保证网络通信效率。这种模式下ACK不再是对每个数据段分别确认，而是发送端主机在发送了一个段后不必一直等待ACK，它会继续发送。

![img](https://img-blog.csdnimg.cn/img_convert/cd7da62d51b7dbf42e548e02d6e54328.png)

滑动窗口的大小指的是不需要等待ACK到达，可以继续发送的数据段的大小，以上图为例，图中的窗口大小就是4000字节，即四个段。通过图示可知，主机A在发送前四个段的时候，不用等待主机B的ACK，就可以连续发送。

当主机A收到了第一个ACK之后，滑动窗口向后滑动，继续发送第五个段的数据包，并以此类推，这个滑动窗口是由操作系统内核来进行维护的，其作用就是在发送缓冲区中记录当前还有哪些数据没有收到ACK，只有被ACK确认过的额数据才能从缓冲区中删掉，这样就可以保证如果出现重传需求，发送端可以立刻在发送缓冲区的未确认部分找到历史数据，直接发送。而不用担心历史数据遗失的问题了。

滑动窗口越大，网络的吞吐率也就越高。

![img](https://img-blog.csdnimg.cn/img_convert/91743888b540133598fdaa78378740b1.png)

滑动窗口机制设计的非常巧妙，可以用顺序的方式将多个段同时发送提高通信的性能，假如上图中ACK 2001在网络中阻塞或者丢失，我们最后只收到了ACK 5001，那我们还需要重传2001~3000这个数据段吗？答案明显是不用的，因为TCP的确认应答机制明确了ACK之前编号的数据一定已经收到，因此如果我们直接收到了ACK 5001，那在上图中，我们就可以直接将滑动窗口向右移动到5001，并继续将窗口中的数据段连续发送出去！

因为滑动窗口的存在，将整个发送缓冲区分成三个部分，分别是已经发送且收到ACK的数据，已经发送还未收到ACK的数据，和还没有发送的数据，已经收到ACK这部分的数据就可以被清除了，不过缓冲区是开辟在计算机内存中的一部分空间，其容量是有限制的，这就要求滑动窗口机制可以重复使用之前用过的空间，所以发送端的缓冲区我们可以认为是一个环形队列。

![img](https://img-blog.csdnimg.cn/img_convert/1f10f847572ac887628da4b16610e372.png)

TCP引入了一些技术和设计来做网络流控，Sliding Window是其中一个技术。 TCP头里有一个字段叫Window，又叫Advertised-Window，这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。 为了说明滑动窗口，我们需要先看一下TCP缓冲区的一些数据结构：

![img](https://img-blog.csdnimg.cn/img_convert/8f8675830351cb4736a64567d8a33f33.png)

![img](https://img-blog.csdnimg.cn/img_convert/6954c232952caeb3e8ecc90b9b1d624e.png)

上图中，我们可以看到：

- 接收端LastByteRead指向了TCP缓冲区中读到的位置，NextByteExpected指向的地方是收到的连续包的最后一个位置，LastByteRcved指向的是收到的包的最后一个位置，我们可以看到中间有些数据还没有到达，所以有数据空白区。
- 发送端的LastByteAcked指向了被接收端Ack过的位置（表示成功发送确认），LastByteSent表示发出去了，但还没有收到成功确认的Ack，LastByteWritten指向的是上层应用正在写的地方。

于是：

- 接收端在给发送端回ACK中会汇报自己的AdvertisedWindow = MaxRcvBuffer – LastByteRcvd – 1;
- 而发送方会根据这个窗口来控制发送数据的大小，以保证接收方可以处理。

下面我们来看一下发送方的滑动窗口示意图：

![img](https://img-blog.csdnimg.cn/img_convert/9f38b73b527126d50362db7539e76a97.png)

下面我们来看一个接受端控制发送端的图示：

![img](https://img-blog.csdnimg.cn/img_convert/69ed13e25152b6aab2decdc67010d3a4.png)

###### Zero Window

上图，我们可以看到一个处理缓慢的Server（接收端）是怎么把Client（发送端）的TCP Sliding Window给降成0的。此时，你一定会问，如果Window变成0了，TCP会怎么样？是不是发送端就不发数据了？是的，发送端就不发数据了，你可以想像成“Window Closed”，那你一定还会问，如果发送端不发数据了，接收方一会儿Window size 可用了，怎么通知发送端呢？

解决这个问题，TCP使用了Zero Window Probe技术，缩写为ZWP，也就是说，发送端在窗口变成0后，会发ZWP的包给接收方，让接收方来ack他的Window尺寸，一般这个值会设置成3次，第次大约30-60秒（不同的实现可能会不一样）。如果3次过后还是0的话，有的TCP实现就会发RST把链接断了。

> 注意：只要有等待的地方都可能出现DDoS攻击，Zero Window也不例外，一些攻击者会在和HTTP建好链发完GET请求后，就把Window设置为0，然后服务端就只能等待进行ZWP，于是攻击者会并发大量的这样的请求，把服务器端的资源耗尽。（关于这方面的攻击，大家可以移步看一下[Wikipedia的SockStress词条(opens new window)](http://en.wikipedia.org/wiki/Sockstress)）

另外，Wireshark中，你可以使用tcp.analysis.zero_window来过滤包，然后使用右键菜单里的follow TCP stream，你可以看到ZeroWindowProbe及ZeroWindowProbeAck的包。

## TCP的拥堵处理 ——Congestion Handling

**如果网络上的延时突然增加，那么，TCP对这个事做出的应对只有重传数据，但是，重传会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，于是，这个情况就会进入恶性循环被不断地放大。试想一下，如果一个网络内有成千上万的TCP连接都这么行事，那么马上就会形成“网络风暴”，TCP这个协议就会拖垮整个网络**，这是一个灾难。

所以，TCP不能忽略网络上发生的事情，而无脑地一个劲地重发数据，对网络造成更大的伤害。对此TCP的设计理念是：**TCP不是一个自私的协议，当拥塞发生的时候，要做自我牺牲。就像交通阻塞一样，每个车都应该把路让出来，而不要再去抢路了**。

拥塞控制主要是四个算法：**1）慢启动，2）拥塞避免，3）拥塞发生，4）快速恢复**。这四个算法不是一天都搞出来的，这个四算法的发展经历了很多时间，到今天都还在优化中。

##### 1.慢启动算法——Slow Start

慢启动的意思是，刚刚加入网络的连接，一点一点地提速，不要一上来就像那些特权车一样霸道地把路占满。新同学上高速还是要慢一点，不要把已经在高速上的秩序给搞乱了。

慢启动的算法如下(cwnd全称Congestion Window 拥塞窗口)：

1）连接建好的开始先初始化cwnd = 1，表明可以传一个MSS大小的数据。

2）每当收到一个ACK，cwnd++; 呈线性上升

3）每当过了一个RTT，cwnd = cwnd*2; 呈指数让升

4）还有一个ssthresh（slow start threshold 慢启动门限），当cwnd >= ssthresh时，就会进入“拥塞避免算法”

##### 2.拥塞避免算法——Congestion Avoidance

ssthresh（slow start threshold），是一个上限，当cwnd >= ssthresh时，就会进入“拥塞避免算法”。一般来说ssthresh的值是65535，单位是字节，当cwnd达到这个值时后，算法如下：

- 1）收到一个ACK时，cwnd = cwnd + 1/cwnd
- 2）当每过一个RTT时，cwnd = cwnd + 1

这样就可以避免增长过快导致网络拥塞，慢慢的增加调整到网络的最佳值。很明显，是一个线性上升的算法。

![img](https://img-blog.csdnimg.cn/img_convert/a743476e8b5de89e49ec21f599775bca.png)

##### 3.拥塞状态时的算法

前面我们说过，当丢包的时候，会有两种情况：

- 1）等到RTO超时，重传数据包。TCP认为这种情况太糟糕，反应也很强烈。
- - sshthresh = cwnd /2
  - cwnd 重置为 1
- - 进入慢启动过程
- 2）Fast Retransmit算法，也就是在收到3个duplicate ACK时就开启重传，而不用等到RTO超时。
- - TCP Tahoe的实现和RTO超时一样。
  - TCP Reno的实现是：
- - - cwnd = cwnd /2
    - sshthresh = cwnd
- - - 进入快速恢复算法——Fast Recovery

上面我们可以看到RTO超时后，sshthresh会变成cwnd的一半，这意味着，如果cwnd<=sshthresh时出现的丢包，那么TCP的sshthresh就会减了一半，然后等cwnd又很快地以指数级增涨爬到这个地方时，就会成慢慢的线性增涨。我们可以看到，TCP是怎么通过这种强烈地震荡快速而小心得找到网站流量的平衡点的。

##### 4.快速回复算法—— Fast Recovery

###### 4.1 TCP Reno

这个算法定义在RFC5681。快速重传和快速恢复算法一般同时使用。快速恢复算法是认为，你还有3个Duplicated Acks说明网络也不那么糟糕，所以没有必要像RTO超时那么强烈。 注意，正如前面所说，进入Fast Recovery之前，cwnd 和 sshthresh已被更新：

- cwnd = cwnd /2
- sshthresh = cwnd

然后，真正的Fast Recovery算法如下：

- cwnd = sshthresh + 3 * MSS （3的意思是确认有3个数据包被收到了）
- 重传Duplicated ACKs指定的数据包
- 如果再收到 duplicated Acks，那么cwnd = cwnd +1
- 如果收到了新的Ack，那么，cwnd = sshthresh ，然后就进入了拥塞避免的算法了。

如果你仔细思考一下上面的这个算法，**你就会知道，上面这个算法也有问题，那就是——它依赖于3个重复的Acks**。注意，3个重复的Acks并不代表只丢了一个数据包，很有可能是丢了好多包。但这个算法只会重传一个，而剩下的那些包只能等到RTO超时，于是，进入了恶梦模式——超时一个窗口就减半一下，多个超时会超成TCP的传输速度呈级数下降，而且也不会触发Fast Recovery算法了。

通常来说，正如我们前面所说的，SACK或D-SACK的方法可以让Fast Recovery或Sender在做决定时更聪明一些，但是并不是所有的TCP的实现都支持SACK（SACK需要两端都支持），所以，需要一个没有SACK的解决方案。而通过SACK进行拥塞控制的算法是FACK。

###### 4.2 TCP New Reno

TCP New Reno（参见 RFC 6582 ）算法提出来，主要就是在没有SACK的支持下改进Fast Recovery算法的——

当sender这边收到了3个Duplicated Acks，进入Fast Retransimit模式，开发重传重复Acks指示的那个包。如果只有这一个包丢了，那么，重传这个包后回来的Ack会把整个已经被sender传输出去的数据ack回来。如果没有的话，说明有多个包丢了。我们叫这个ACK为Partial ACK。 一旦Sender这边发现了Partial ACK出现，那么，sender就可以推理出来有多个包被丢了，于是乎继续重传sliding window里未被ack的第一个包。直到再也收不到了Partial Ack，才真正结束Fast Recovery这个过程 我们可以看到，这个“Fast Recovery的变更”是一个非常激进的玩法，他同时延长了Fast Retransmit和Fast Recovery的过程。

#### 下面我们来看一个简单的图示以同时看一下上面的各种算法的样子：

![img](https://img-blog.csdnimg.cn/img_convert/b85553444f1b1450ce54fc06cf5cfde6.png)



## 拥塞控制

自从有了上述介绍的滑动窗口之后，TCP传播的效率大大提升，不再是一个个单独发送数据段，而是连续大量发送数据段，但是如果刚刚建立了连接就大量发送数据，很有可能引发其它问题。

计算机网络是一个共享的环境，上面连接着许多的计算机，就好比一条高速公路，大家都可以在上面行驶，如果某一时间已经堵车了，但还有大量的汽车驶上该条公路，那么就会引发整条公路的交通陷入瘫痪。计算机网络也是如此，如果网络环境已经比较拥堵，仍然发送大量的数据段，是非常危险的行为。因此TCP为了防止这种问题的出现，在通信一开始的时候会采取慢启动的机制，先探查一下当前的网络状况，再确定按照多大的速度传输数据。

为了在发送端可以进行调节发送数据的量，定义了一个**“拥塞窗口”**的概念，在慢启动开始时，拥塞窗口在发送开始的时候大小设置为1，每次收到一个ACK应答，拥塞窗口就翻倍，这样就实现了指数级增长，每次发送数据的时候，会将拥塞窗口和接收端的窗口大小字段进行比较，取两者中更小的那个作为发送端的滑动窗口大小。

**慢启动**只是初始的时候比较慢，但是增长速度较快，其拥塞窗口的增长速度是指数级别的，但是指数增长是在是太快了，所以我们需要规定一个阈值，当拥塞窗口超过阈值后，不再以指数方式增长，而是以线性方式增长。当遇到网络阻塞后，将拥塞窗口置为1，并将阈值设置为上次出现拥塞情况时拥塞窗口大小的二分之一（现在已经不再使用了），目前使用的是快速回复，直接将拥塞窗口置为上次出现拥塞情况时拥塞窗口大小的二分之一。

![img](https://img-blog.csdnimg.cn/img_convert/a3ee70cd4e0bbfeb758049ac488b1f93.png)

总结一下，TCP协议正如它的名字一样，传输控制协议，不仅要建立、断开和保持传输所用的连接，而且要在传输过程中进行控制，不可以发的太慢，也不可以发的太快。所以TCP的可靠性为网络通信提供了安全，而TCP的对于连接的控制则大大提高了网络传输的效率。
